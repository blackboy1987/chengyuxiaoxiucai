"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.values = exports.SlotView = void 0;
const t = __importStar(require("@babel/types"));
const lodash_1 = require("lodash");
const macro_1 = require("@remax/macro");
const constants_1 = require("./compiler/static/constants");
const nativeComponent_1 = require("../utils/nativeComponent");
exports.SlotView = {
    id: 'slot-view',
    props: [],
};
const hostComponentManifests = new Map();
const nativeComponentManifests = new Map();
function getNativePluginComponentName(path) {
    const node = path.node;
    const openingElement = node.openingElement;
    if (!t.isJSXIdentifier(openingElement.name)) {
        return false;
    }
    const name = openingElement.name.name;
    const binding = path.scope.getBinding(name);
    if (!binding) {
        return false;
    }
    const bindingPath = binding.path;
    if (!bindingPath || !t.isVariableDeclarator(bindingPath.node)) {
        return false;
    }
    if (!t.isCallExpression(bindingPath.node.init) ||
        !t.isIdentifier(bindingPath.node.init.callee) ||
        bindingPath.node.init.callee.name !== 'createNativeComponent') {
        return false;
    }
    const arg0 = bindingPath.node.init.arguments[0];
    if (!t.isStringLiteral(arg0)) {
        return false;
    }
    return arg0.value;
}
function getNativeComponentName(path, importer, config) {
    const node = path.node;
    const openingElement = node.openingElement;
    if (!t.isJSXIdentifier(openingElement.name)) {
        return false;
    }
    const name = openingElement.name.name;
    const binding = path.scope.getBinding(name);
    if (!binding) {
        return false;
    }
    const bindingPath = binding.path;
    // binding
    if (!bindingPath || !t.isImportDefaultSpecifier(bindingPath.node)) {
        return false;
    }
    const importPath = bindingPath.parentPath;
    if (t.isImportDeclaration(importPath)) {
        const importNode = importPath.node;
        const source = importNode.source.value;
        const sourcePath = nativeComponent_1.getSourcePath(source, importer, config);
        if (!nativeComponent_1.isNativeComponent(sourcePath)) {
            return;
        }
        return macro_1.registerNativeComponent(sourcePath, importer);
    }
    return false;
}
function getRemaxHostComponentName(path) {
    const node = path.node;
    const openingElement = node.openingElement;
    if (!t.isJSXIdentifier(openingElement.name)) {
        return false;
    }
    const name = openingElement.name.name;
    const binding = path.scope.getBinding(name);
    if (!binding) {
        return false;
    }
    const bindingPath = binding.path;
    // binding
    if (!bindingPath || !t.isImportSpecifier(bindingPath.node)) {
        return false;
    }
    const importPath = bindingPath.parentPath;
    if (t.isImportDeclaration(importPath)) {
        const importNode = importPath.node;
        if (/^@?remax\//.test(importNode.source.value)) {
            return lodash_1.kebabCase(bindingPath.node.imported.name);
        }
    }
    return false;
}
function shouldRegisterProp(api, propName, isNative, hostComponent) {
    var _a;
    // key 属性
    if (propName === 'key') {
        return true;
    }
    // turboPages 模板 ID
    if (propName === constants_1.TEMPLATE_ID) {
        return true;
    }
    // 原生组件的属性都要注册
    if (isNative) {
        return true;
    }
    // host component 上的标准属性
    if ((_a = hostComponent === null || hostComponent === void 0 ? void 0 : hostComponent.alias) === null || _a === void 0 ? void 0 : _a[propName]) {
        return true;
    }
    const prefix = `${api.adapter.target}-`;
    // 平台特定属性
    if (propName.startsWith(prefix)) {
        return true;
    }
    // data 属性
    if (propName.startsWith('data-')) {
        return true;
    }
    return false;
}
function aliasProp(api, propName, hostComponent) {
    var _a;
    const prefix = `${api.adapter.target}-`;
    if (propName.startsWith(prefix)) {
        return propName.replace(new RegExp(`^${prefix}`), '');
    }
    return ((_a = hostComponent === null || hostComponent === void 0 ? void 0 : hostComponent.alias) === null || _a === void 0 ? void 0 : _a[propName]) || propName;
}
function registerSlotViewProps(api, node) {
    let props = [];
    node.openingElement.attributes.forEach(attr => {
        var _a;
        if (t.isJSXSpreadAttribute(attr)) {
            props = [...props, ...(((_a = api.getHostComponents().get('view')) === null || _a === void 0 ? void 0 : _a.props) || [])];
            return;
        }
        const prop = attr.name;
        let propName = '';
        if (t.isJSXIdentifier(prop)) {
            propName = prop.name;
        }
        if (t.isJSXNamespacedName(prop)) {
            propName = prop.namespace.name + ':' + prop.name.name;
        }
        props.push(propName);
    });
    return (props
        // 无需收集 slot 字段
        .filter(p => p !== 'slot')
        .map(prop => aliasProp(api, prop, api.getHostComponents().get('view')))
        .sort());
}
function isSlotView(componentName, node) {
    if (!node || componentName !== 'view') {
        return false;
    }
    if (node.openingElement.attributes.find(attr => t.isJSXAttribute(attr) && attr.name.name === 'slot')) {
        return true;
    }
    return false;
}
function registerProps(api, id, node, isNative) {
    const hostComponent = api.getHostComponents().get(id);
    if (!isNative && !hostComponent) {
        return;
    }
    let props = [];
    if (hostComponent) {
        props = api.processProps(id, hostComponent.props.slice(), hostComponent.additional, node);
    }
    if (node) {
        node.openingElement.attributes.forEach(attr => {
            if (t.isJSXSpreadAttribute(attr)) {
                return;
            }
            const prop = attr.name;
            let propName = '';
            if (t.isJSXIdentifier(prop)) {
                propName = prop.name;
            }
            if (t.isJSXNamespacedName(prop)) {
                propName = prop.namespace.name + ':' + prop.name.name;
            }
            /**
             * React 运行时读不到 key
             * 所以在这里如果发现组件上设置了 key
             * 就再设置一个别名 __key
             * 然后在模板里写死 key="{{item.props.__key}}"
             */
            if (propName === 'key') {
                node.openingElement.attributes.push(t.jsxAttribute(t.jsxIdentifier('__key'), attr.value));
            }
            if (!shouldRegisterProp(api, propName, !!isNative, hostComponent)) {
                return;
            }
            props.push(propName);
        });
    }
    if (isNative) {
        return Array.from(new Set(props
            // 剔除 ref，在 axml 特殊处理
            .filter(p => p !== 'ref')
            .filter(Boolean)
            .map(prop => prop.replace('className', 'class')))).sort();
    }
    return Array.from(new Set(props
        // 无需收集 slot 字段
        .filter(p => p !== 'slot')
        // 静态编译辅助字段
        .filter(p => p !== constants_1.LEAF)
        .filter(p => p !== constants_1.ENTRY)
        .filter(Boolean)
        .map(prop => aliasProp(api, prop, hostComponent)))).sort();
}
function registerNativeComponentManifest(api, id, node) {
    const props = registerProps(api, id, node, true) || [];
    const component = {
        id,
        props,
        additional: false,
        type: 'native',
    };
    const registeredComponent = nativeComponentManifests.get(id);
    if (registeredComponent) {
        component.props = Array.from(new Set([...props, ...registeredComponent.props])).sort();
    }
    nativeComponentManifests.set(id, component);
}
function registerHostComponentManifest(api, id, phase, node, additional) {
    if (!api.shouldHostComponentRegister(id, phase, additional)) {
        return;
    }
    let props = [];
    if (isSlotView(id, node)) {
        // isSlotView 确保了 node 一定存在
        props = registerSlotViewProps(api, node);
        exports.SlotView.props = Array.from(new Set([...exports.SlotView.props, ...props]));
        return;
    }
    else {
        props = registerProps(api, id, node);
    }
    if (!props) {
        return;
    }
    const component = {
        id,
        props,
        additional,
    };
    const registeredComponent = nativeComponentManifests.get(id);
    if (registeredComponent) {
        if (phase === 'extra') {
            return;
        }
        component.props = Array.from(new Set([...props, ...registeredComponent.props])).sort();
    }
    nativeComponentManifests.set(id, component);
}
function hostComponent(api, config) {
    return {
        visitor: {
            JSXElement: (path, state) => {
                const importer = state.file.opts.filename;
                let name = getRemaxHostComponentName(path);
                if (name) {
                    registerHostComponentManifest(api, name, 'jsx', path.node);
                    return;
                }
                name = getNativeComponentName(path, importer, config) || getNativePluginComponentName(path);
                if (name) {
                    registerNativeComponentManifest(api, name, path.node);
                }
            },
        },
    };
}
exports.default = hostComponent;
function values(api) {
    api.getHostComponents().forEach((component, id) => {
        registerHostComponentManifest(api, id, 'extra', undefined, component.additional);
    });
    return [...hostComponentManifests.values(), ...nativeComponentManifests.values()];
}
exports.values = values;
